$ = param => {    if (isString(param)) return new ElementCollection(...document.querySelectorAll(param));    return new ElementCollection(param);}/** * Sends an HTTP Get Request * @param {*} param0  * @param {*} dataType  * @returns  */ $.get = ({ url, data = {}, success = () => { } }, dataType) => $.ajax({ url, data, success }, dataType, 'GET'); /**  * Sends an HTTP Post Request  * @param {*} param0   * @param {*} dataType   * @returns   */ $.post = ({ url, data = {}, success = () => { } }, dataType) => $.ajax({ url, data, success }, dataType, 'POST'); /**  * Sends an HTTP Delete Request  * @param {*} param0   * @param {*} dataType   * @returns   */ $.delete = ({ url, data = {}, success = () => { } }, dataType) => $.ajax({ url, data, success }, dataType, 'DELETE'); /**  * Sends an HTTP Put Request  * @param {*} param0   * @param {*} dataType   * @returns   */ $.put = ({ url, data = {}, success = () => { } }, dataType) => $.ajax({ url, data, success }, dataType, 'PUT'); /**  * Custom function to send HTTP requests on custom methods name  * to be used on the GET, POST, DELETE and PUT methods  * @param {*} param0   * @param {*} dataType   * @param {*} method   * @returns   */ $.ajax = ({ url, data = {}, success = () => { } }, dataType, method) => {     const isGet = method === 'GET';     let callUrl = isGet ? `${url}?${objectToQueryString(data)}` : url;     return new AjaxPromise(         fetch(callUrl, {             method: method,             headers: {                 'Content-Type': dataType             },             data: isGet ? null : data         }).then(response => {             if (!response.ok) throw new Exception(response.status);             response.json();         })             .then(data => {                 success(data);                 return data;             }             )); } 
/** * Class to handle all the javascript Ajax promises */ class AjaxPromise {    constructor(promise) {        this.promise = promise;    }    /**     * Sets the block of code that executes when the promise is done sucessfully     * @param {*} callback      * @returns      */    done = (callback) => {        this.promise.catch(data => {            callback(data);            return data;        });        return this;    }    /**     * Handles the fail on the promise     * @param {*} callback      * @returns      */    fail = (callback) => {        this.promise.catch(callback); return this;    }    /**     * Sets the block of code that always execute no matter     * if the promise fails or not     * @param {*} callback      * @returns      */    always = (callback) => {        this.promise.finally(callback); return this;    }}
/** * Class for handling the Dom elements on the page */  class ElementCollection extends Array {    /**     * Variable to control if the state of the document is ready     */    isReady = this.some(e => e.readyState != null && e.readyState != 'loading');    /**     * Set a function to be called when the document is ready     * @param {*} callback      * @returns      */    ready = (callback) => {        if (!documentIsLoading()) {            callback();            return;        }        this.on('DOMContentLoaded', callback);    }    /**     * Define in wich event an callback function should be called      * on the current DOM object     * @param {*} event      * @param {*} callback      * @returns      */    on = (event, callback) => this.forEach(e => e.addEventListener(event, callback));    /**     * Define in wich event an callback function should be called      * on the current DOM object only when the selector matches      * @param {*} event      * @param {*} selector      * @param {*} callback      * @returns      */    on = (event, selector, callback) => {        this.forEach(el =>            el.addEventListener(event, ev =>                ev.target.matches(selector) && callback()            )        );        return this;    }    /**     * Get the next DOM element on the array     * @returns ElementArray     */    next = () => this.map(e => e.nextElementSibling).filter(e => e != null);    /**     * Get the previous DOM element on the array     * @returns ElementArray     */    prev = () => this.map(e => e.previousElementSibling).filter(e => e != null);    /**     * Remove the css class from an element     * @param {*} className      * @returns ElementCollection     */    removeClass = className => {        this.forEach(e => e.classList.remove(className));        return this;    }    /**     * Adds a css class to an element     * @param {*} className      * @returns ElementCollection     */    addClass = className => {        this.forEach(e => e.classList.add(className));        return this;    }    /**     * Changes the css property on the selected element     * @param {*} property      * @param {*} value      * @returns      */    css = (property, value) => {        this.forEach(e => {            e.style[toCamelCase(property)] = value;        });        return this;    }}
/** * Custom exception class to handle the errors on the api */ class Exception extends Error {}
isString = value => typeof value === 'string' || value instanceof String;documentIsLoading = () => document.readyState == 'loading';objectToQueryString = object => Object.entries(object).map(([key, value]) => `${key}=${value}`).join('$');toCamelCase = value => value.replace(/(-[a-z])/, g => g.replace('-', '').toUpperCase());